Notes from Lesson 4 Remix Fund Me:

What are we making?

We're making a crowd funding app like kickstart, or a way to raise money.
Allowing users to send EVM based coin and allow owner of the contract to withdraw funds to spend on their project.
We're gonna deploy on testnet.
A minimum funding amount will be set to $5.

To allow a smart contract to receive Ether or native cryptocurrency, we need to add the "payable" modifier in function signature.
Just like wallets, contracts can also hold coins.
You can access the value sent to the function with "msg.value" where value is the amount sent.

Use the require function to put checks in the function. If it passes it'll continue otherwise it'll revert the transaction.

What is a revert?
A revert undos any action that have been done, and sends the remaining gas back.
If you send a failed transaction, you will still spend gas but it'll revert everything back and return the remaining gas back.

Every single transaction you send will have following fields:

1. Nonce: tx count for the account
2. Gas Price: price per unit of gas(in wei)
3. Gas limit: max gas that this tx can use
4. To: address that the tx is sent to
5. value: amount of wei to send
6. Data: what to send to the "To" address
7. v, r, s: components of tx signature

How to convert a dollar value to the equivalent of ether in order to make the minimum amount check.
We'll be using decentralized oracles for this, chainlink.


The smart contract connectivity problem or the oracle problem is that smart contracts can not see or compute with external/outside data.
because if smart contracts had different values per computation, like an API call, or a random number, or 1 + 1 for a variable then they 
will never reach consensus that's why we rely on oracles to bring in external data to the smart contracts.

Centralized oracles are a point of failure, because they're not decentralized. We don't need our data from centralized nodes.
Chainlink has decentralized oracles network which is awesome for this thing.

Blockchains can't do API calls

Chainlink networks can be completely customized to bring any data or any computation that we want.
Chainlink is a technology to get external data and computation into our smart contracts, and getting that data in a decentralized manner.
Chainlink data feeds are powering over $50 billion in Defi World

Interfaces:

Interfaces are contracts which only has function signatures in it. It doesn't have a constructor neither any state variables.
Interfaces are used to standardize different smart contracts for interoperability. 
Even though the interface itself doesn't have any logic, when a contract implements that interface, 
it provides the implementation details and return values for the functions defined in the interface.

Interfaces act as a way to enforce a contract's adherence to a specific set of functions, enabling contracts 
to interact in a standardized manner. By implementing the interface, the contract guarantees the presence of
those functions, allowing other contracts or external code to utilize the contract's functionality through 
the interface without needing knowledge of the specific implementation details.

You can typecast variables by wrapping variables into parenthesis of the variable type, eg:

uint256 price = 10;
typecast to int256
int256(price);

Always multiply before dividing because only whole numbers work in solidity.

"Gas estimation failed" error generally means something is wrong in the code.

msg.sender refers to whoever calls the function.
msg.value refers to the amount of Ether send with the transaction, which is not the gas fees it is irrespective of the gas fees.

You can add labels to mapping like this, to make it easier to understand the mapping.

mapping(address To => uint256 amountSent)